import {createSelector} from 'reselect';
import moment from 'moment';
import {OrderedMap} from 'immutable';
import {formatDate} from '@ciscospark/react-component-utils';
import {FEATURE_GROUP_CALLING} from '@ciscospark/redux-module-features';

const getWidget = (state) => state.widgetRecents;
const getSpark = (state) => state.spark;
const getCurrentUser = (state, ownProps) => ownProps.currentUser;
const getAvatars = (state) => state.avatar;
const getTeams = (state) => state.teams.get('byId');
const getFeatures = (state) => state.features;
const getSpaces = (state) => state.spaces.get('byId');
const getUsers = (state) => state.users.get('byId');
const getActivities = (state) => state.activities.get('byId');
const getCalls = (state) => state.media.byId;
const getMercuryStatus = (state) => state.mercury.get('status');


function sortByNewest(space) {
  return -moment(space.lastReadableActivityDate).format('x');
}

function constructSpace(space) {
  const {
    lastSeenActivityDate,
    lastReadableActivityDate,
    id
  } = space;
  const isUnread = lastSeenActivityDate ? moment(lastSeenActivityDate).isBefore(lastReadableActivityDate) : true;

  return {
    id,
    locusUrl: space.locusUrl,
    type: space.type,
    lastActivityTime: formatDate(lastReadableActivityDate),
    lastActivityTimestamp: lastReadableActivityDate,
    name: 'Untitled',
    participants: space.participants,
    published: space.published,
    isLocked: space.tags && space.tags.includes('LOCKED'),
    isUnread,
    isDecrypting: space.isDecrypting
  };
}

function constructOneOnOne({space, currentUser, users}) {
  const thisSpace = constructSpace(space);

  // Get the user ID of the participant that isn't current user
  const toPersonId = space.participants.find((p) => p !== currentUser.id);
  const toPerson = users.get(toPersonId);
  if (toPerson) {
    thisSpace.toPersonId = toPersonId;
    thisSpace.toPersonEmail = toPerson.email;
    thisSpace.name = toPerson.displayName;
  }
  return thisSpace;
}

function constructGroup({space, team}) {
  const {
    id,
    displayName
  } = space;
  const thisSpace = constructSpace(space);
  thisSpace.name = displayName || 'Untitled';
  if (team) {
    thisSpace.teamName = team.displayName;
    thisSpace.teamColor = team.color;
    thisSpace.teamId = team.id;
    if (id === team.generalConversationId) {
      thisSpace.name = 'General';
    }
  }
  return thisSpace;
}

const getIncomingCall = createSelector(
  [getCalls],
  (calls) => calls.find((call) => call.isIncoming && !call.isDismissed)
);

const getRecentSpaces = createSelector(
  [getSpaces, getActivities, getCurrentUser, getUsers, getTeams],
  (spaces, activities, currentUser, users, teams) => {
    let recents = new OrderedMap();

    spaces.toOrderedMap().sortBy(sortByNewest).forEach((space) => {
      if (!space.isHidden && !space.isFetching) {
        const spaceId = space.id;
        const team = teams.get(space.team);
        let constructedSpace;
        if (space.type === 'direct') {
          constructedSpace = constructOneOnOne({space, users, currentUser});
        }
        else {
          constructedSpace = constructGroup({space, team});
        }

        // Get Latest Activity
        const activity = activities.get(space.latestActivity);
        if (activity) {
          const actorId = activity.actor;
          const actor = users.get(actorId);
          constructedSpace.latestActivity = {
            actorName: actor && actor.displayName ? actor.displayName.split(' ')[0] : '',
            type: activity.type,
            object: activity.object,
            text: activity.object.displayName,
            actor
          };
        }

        recents = recents.set(spaceId, constructedSpace);
      }
    });
    return recents;
  }
);


const getRecentSpacesWithDetail = createSelector(
  [getRecentSpaces, getAvatars, getCalls],
  (recentSpaces, avatars, calls) => {
    const avatarItems = avatars.get('items');

    return recentSpaces.map((space) => {
      const s = Object.assign({}, space);
      // Get Avatar
      if (avatarItems.count()) {
        if (s.type === 'direct') {
          s.avatarUrl = avatarItems.get(s.toPersonId);
        }
        else {
          s.avatarUrl = avatarItems.get(s.id);
        }
      }
      // Get current call
      if (calls.size && calls.has(s.locusUrl)) {
        s.call = calls.get(s.locusUrl);
        s.callStartTime = s.call.startTime;
      }

      return s;
    });
  }
);

const getRecentsWidgetProps = createSelector(
  [
    getWidget,
    getRecentSpacesWithDetail,
    getSpark,
    getFeatures,
    getSpaces,
    getIncomingCall,
    getMercuryStatus
  ],
  (
    widget,
    spacesList,
    spark,
    features,
    spaces,
    incomingCall,
    mercuryStatus
  ) => {
    let lastActivityDate;
    if (spacesList && spacesList.count()) {
      lastActivityDate = spacesList.last().lastActivityTimestamp;
    }
    const spacesListArray = spacesList.toArray();
    const hasGroupCalling = features.getIn(['items', FEATURE_GROUP_CALLING]);
    return {
      widgetStatus: widget.get('status').toJS(),
      sparkState: spark.get('status').toJS(),
      sparkInstance: spark.get('spark'),
      widgetRecents: widget,
      spaces,
      spacesList: spacesListArray,
      hasGroupCalling,
      lastActivityDate,
      incomingCall,
      mercuryStatus: mercuryStatus.toJS()
    };
  }
);

export default getRecentsWidgetProps;
